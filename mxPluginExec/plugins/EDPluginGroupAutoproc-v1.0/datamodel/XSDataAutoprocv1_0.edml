targetNamespace "http://www.edna-site.org"
import XSDataCommon.XSDataDouble
import XSDataCommon.XSDataString
import XSDataCommon.XSDataInteger
import XSDataCommon.XSDataDouble
import XSDataCommon.XSDataVectorDouble
import XSDataCommon.XSDataInput
import XSDataCommon.XSDataResult
import XSDataCommon.XSDataBoolean
import XSDataCommon.XSDataFile


complex type XSDataRange {
        begin : integer
        end   : integer
}

complex type XSDataMinimalXdsIn extends XSDataInput {
        input_file		: XSDataString
        job			: XSDataString optional
        maxproc			: XSDataInteger optional
        maxjobs			: XSDataInteger optional
        friedels_law		: XSDataBoolean optional
        resolution_range	: XSDataDouble [] optional
        spot_range		: XSDataRange [] optional
	spacegroup		: XSDataInteger optional
	unit_cell		: XSDataString optional
}

complex type XSDataMinimalXdsOut extends XSDataResult {
        succeeded : XSDataBoolean
}

complex type XSDataXdsOutputFile extends XSDataInput {
        correct_lp : XSDataFile
        gxparm     : XSDataFile optional
}

complex type XSDataXdsCompletenessEntry {
        res				: XSDataDouble
        observed			: XSDataDouble
        unique				: XSDataDouble
        possible			: XSDataDouble
        complete			: XSDataDouble
        rfactor				: XSDataDouble
        isig				: XSDataDouble
        half_dataset_correlation	: XSDataDouble
}

complex type XSData2DCoordinates {
        x : XSDataDouble
        y : XSDataDouble
}

complex type XSDataXdsOutput extends XSDataResult {
        completeness_entries             : XSDataXdsCompletenessEntry []
        total_completeness               : XSDataXdsCompletenessEntry
        crystal_mosaicity                : XSDataDouble
        direct_beam_coordinates          : XSDataVectorDouble
        direct_beam_detector_coordinates : XSData2DCoordinates
        detector_origin                  : XSData2DCoordinates
        crystal_to_detector_distance     : XSDataDouble
        coordinates_of_unit_cell_a_axis  : XSDataVectorDouble
        coordinates_of_unit_cell_b_axis  : XSDataVectorDouble
        coordinates_of_unit_cell_c_axis  : XSDataVectorDouble
        cell_a                           : XSDataDouble
        cell_b                           : XSDataDouble
        cell_c                           : XSDataDouble
        cell_alpha                       : XSDataDouble
        cell_beta                        : XSDataDouble
        cell_gamma                       : XSDataDouble
        unit_cell_constants              : XSDataDouble [] optional
        sg_number                        : XSDataInteger optional
        /* the XDS run and the parsing are in separate plugins we
        cannot use getWorkingDirectory to find where XDS ran so we
        include that here. Yes, this is not pretty. */
        xds_run_directory                : XSDataString
}

complex type XSDataResCutoff extends XSDataInput {
        xds_res              : XSDataXdsOutput
        completeness_entries : XSDataXdsCompletenessEntry []
        detector_max_res     : XSDataDouble optional
        //XXX : remove from model as it is only pass through?
        total_completeness   : XSDataXdsCompletenessEntry
        res_override         : XSDataDouble optional

        // the parameters we can use for cutoff
        completeness_cutoff  : XSDataDouble optional
        isig_cutoff          : XSDataDouble optional
        r_value_cutoff       : XSDataDouble optional
        cc_half_cutoff       : XSDataDouble optional
}

complex type XSDataResCutoffResult extends XSDataResult {
        res            : XSDataDouble
        bins           : XSDataDouble []
        //XXX : those 3 vars are only pass-through. Remove?
        total_complete : XSDataDouble
        total_rfactor  : XSDataDouble
        total_isig     : XSDataDouble
}

complex type XSDataXscaleInputFile extends XSDataInput {
	// usually one of the path will be None depending on whether
	// we're on the anom or noanom path
        path_anom	: XSDataString optional
	path_noanom	: XSDataString optional
        res		: XSDataDouble
}

complex type XSDataXscaleGeneratedFiles extends XSDataResult {
        hkl_anom_merged       : XSDataString
        lp_anom_merged        : XSDataString
        stats_anom_merged     : XSDataXscaleParsedOutput

        hkl_noanom_merged     : XSDataString
        lp_noanom_merged      : XSDataString
        stats_noanom_merged   : XSDataXscaleParsedOutput

        hkl_anom_unmerged     : XSDataString
        lp_anom_unmerged      : XSDataString
        stats_anom_unmerged   : XSDataXscaleParsedOutput

        hkl_noanom_unmerged   : XSDataString
        lp_noanom_unmerged    : XSDataString
        stats_noanom_unmerged : XSDataXscaleParsedOutput
}

complex type XSDataXscaleInput extends XSDataInput {
        merge               : XSDataBoolean
        friedels_law        : XSDataBoolean
        xds_files           : XSDataXscaleInputFile []
        unit_cell_constants : XSDataDouble []
        sg_number           : XSDataInteger
        bins                : XSDataDouble [] optional
}

complex type XSDataXscaleOutput extends XSDataResult {
        succeeded : XSDataBoolean
        hkl_file  : XSDataString optional
        lp_file   : XSDataString optional
}

complex type XSDataXscaleParsingInput extends XSDataInput {
        lp_file : XSDataString
}

complex type XSDataXscaleCompletenessEntry extends XSDataXdsCompletenessEntry {
        multiplicity : XSDataDouble
}

complex type XSDataXscaleParsedOutput extends XSDataResult {
        total_completeness   : XSDataXscaleCompletenessEntry
        completeness_entries : XSDataXscaleCompletenessEntry []
}


/* In the original pipeline XDS is simply rerun in the same dir since
edna insists on running each plugin into its separate directory we
will simply require where the previous run take place and link the
useful files from there. Yes, this is not pretty */

complex type XSDataXdsGenerateInput extends XSDataInput {
        previous_run_dir : XSDataString
        resolution       : XSDataDouble
}

// we are only interested in that one file
complex type XSDataXdsGenerateOutput extends XSDataResult {
        hkl_anom           : XSDataString
        hkl_no_anom        : XSDataString
        correct_lp_anom    : XSDataString
        correct_lp_no_anom : XSDataString
        integrate_anom     : XSDataString
        integrate_noanom   : XSDataString
        gxparm             : XSDataString
}

complex type XSDataAutoprocInput extends XSDataInput {
        input_file		: XSDataFile
        res_override		: XSDataDouble optional
        //cutoffs
        completeness_cutoff	: XSDataDouble optional
        isig_cutoff		: XSDataDouble optional
        r_value_cutoff		: XSDataDouble optional
        cc_half_cutoff		: XSDataDouble optional

        data_collection_id	: XSDataInteger optional
        detector_max_res	: XSDataDouble optional
        low_resolution_limit	: XSDataDouble optional
        nres			: XSDataDouble optional

	spacegroup		: XSDataString optional
	unit_cell		: XSDataString optional // space separated numerical values

        output_file		: XSDataFile
}


// these are use by the subplugins of the general file conversion
// control plugin


// this contpains the information for the 4 conversion plugins
complex type XSDataFileConversion extends XSDataInput {
        input_file       : XSDataString
        output_file      : XSDataString
        dataCollectionID : XSDataInteger
        start_image      : XSDataInteger
        end_image        : XSDataInteger
        res              : XSDataDouble
        nres             : XSDataDouble
        anom             : XSDataBoolean
        choose_spacegroup : XSDataString optional
	// optional because the way we get it is fragile and may break
	image_prefix     : XSDataString optional
}

complex type XSDataFileConversionOut extends XSDataResult {
	pointless_sgnumber : XSDataInteger
	pointless_sgstring : XSDataString
	pointless_cell     : XSDataDouble []
	aimless_log        : XSDataString
}

complex type XSDataAutoprocImport extends XSDataInput {
	input_anom	    	: XSDataString
	input_noanom		: XSDataString
	output_directory	: XSDataString
	dataCollectionID	: XSDataInteger
	start_image		    : XSDataInteger
        end_image		: XSDataInteger
        res			    : XSDataDouble
        nres			: XSDataDouble
	image_prefix        : XSDataString optional
    choose_spacegroup   : XSDataString optional
}

complex type XSDataAutoprocImportOut extends XSDataResult {
	files			: XSDataString []
	// Those two come from the noanom data
	pointless_sgnumber	: XSDataInteger
	pointless_sgstring	: XSDataString
	pointless_cell      : XSDataDouble []
	aimless_log_anom    : XSDataString
	aimless_log_noanom	: XSDataString
}

complex type XSDataInputControlDimple extends XSDataInput {
	dataCollectionId : XSDataInteger
	mtzFile : XSDataFile
	pyarchPath : XSDataFile
	imagePrefix : XSDataString optional
	pdbDirectory : XSDataFile optional
}

complex type XSDataResultControlDimple extends XSDataResult {
	dimpleExecutedSuccessfully : XSDataBoolean
}


